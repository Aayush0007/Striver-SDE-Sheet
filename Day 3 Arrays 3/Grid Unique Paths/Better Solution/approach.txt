Solution 2: Dynamic Programming Solution

Intuition: The dynamic programming solution of this problem is a bit extension of the recursive solution. In recursive solutions, there are many overlapping subproblems. In this solution instead of traversing all the possible paths, whenever we get the result we’ll store it in a matrix for future use. Whenever we encounter the same subproblem we directly get the value from the matrix instead of recomputing it. By this memorization technique, we can avoid the recomputation and the time complexity will be drastically reduced. This is the main intuition behind this dynamic programming solution.

Approach: 

Step 1: Take a dummy matrix A[ ][ ]  of size m X n and fill it with -1. 

Step 2: At first, we are at the (0,0) index let’s assume this state as (i,j). From here we can move towards the bottom as well as towards the right and we recursively move until we hit the base case.



Step 3: At any point of time when the recursive call goes out of the boundary (example: let’s assume m = 2, n= 3, and the current position of i and j is (2,0) which is out of matrix boundary), we will return zero because from here there are no possible paths beyond and that is the first base case.



Step 4: Whenever the recursive call reaches the end we’ll return 1 because we have found one possible path to reach the end.



Step 5: The only change in the dynamic programming solution is whenever we are returning answers we store them in the matrix A[i][j] and wherever we are making a recursive call we simply check if that state is already visited or not in other words we’ll check if A[i][j] is -1 or not if it is not -1 that means that there is a subproblem which is repeating. Now instead of recomputing the subproblem, we’ll return the value at A[i][j].