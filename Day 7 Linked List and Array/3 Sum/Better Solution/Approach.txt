Better Approach
Algorithm / Intuition
Intuition:
In the previous approach, we utilized 3 loops, but now our goal is to reduce it to 2 loops. To achieve this, we need to find a way to calculate arr[k] since we intend to eliminate the third loop (k loop). To calculate arr[k], we can derive a formula as follows: 

arr[k] = target – (arr[i]+arr[j]+arr[k]) = 0-(arr[i]+arr[j]+arr[k]) = -(arr[i]+arr[j]+arr[k]) 

So, we will first calculate arr[i] and arr[j] using 2 loops and for the third one i.e. arr[k] we will not use another loop and instead we will look up the value 0-(arr[i]+arr[j]+arr[k]) in the set data structure. Thus we can remove the third loop from the algorithm.

For implementing the search operation of the third element,  we will store all the elements between the indices i and j in a HashSet and then we will search for the third element in the HashSet.

Why we are not inserting all the array elements in the HashSet and then searching for the third element:

Let’s understand this intuition using an example. Assume the given array is {1, 2, -1, -2, 4, 0, -1} and the target = 0. Now, we will notice a situation like the following:


Here, arr[i] = -2 and arr[j] = 4.
Therefore, arr[k] = -(arr[i]+arr[j]) = -(-2+4) = -2

If all the elements were in the set data structure while searching for -2, we would again pick the element at index 3, that is currently pointed by i.
Hence, the triplet will be [arr[i], arr[j], arr[i]]. And this is an invalid triplet. That is why we cannot insert all the elements into the set data structure.
Algorithm:
The steps are as follows:

First, we will declare a set data structure as we want unique triplets.
Then we will use the first loop(say i) that will run from 0 to n-1.
Inside it, there will be the second loop(say j) that will run from i+1 to n-1.
Before the second loop, we will declare another HashSet to store the array elements as we intend to search for the third element using this HashSet.
Inside the second loop, we will calculate the value of the third element i.e. -(arr[i]+arr[j]).
If the third element exists in the HashSet, we will sort these 3 values i.e. arr[i], arr[j], and the third element, and insert it in the set data structure declared in step 1.
After that, we will insert the j-th element i.e. arr[j] in the HashSet as we only want to insert those array elements that are in between indices i and j.
Finally, we will return a list of triplets stored in the set data structure.