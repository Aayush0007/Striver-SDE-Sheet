Naive Approach (Brute-force): 
This approach is not the exact solution according to the question as in this approach we are going to use an extra space i.e. an array. But it is definitely one of the solutions if the question does not contain the constraint of not using any extra space. And also this approach will help to understand the optimal approaches.

Approach:
Assume the size of the given arrays are n and m.

The steps are as follows:

We will first declare a third array, arr3[] of size n+m, and two pointers i.e. left and right, one pointing to the first index of arr1[] and the other pointing to the first index of arr2[].
The two pointers will move like the following:
If arr1[left] < arr2[right]: We will insert the element arr1[left] into the array and increase the left pointer by 1.
If arr2[right] < arr1[left]: We will insert the element arr2[right] into the array and increase the right pointer by 1.
If arr1[left] == arr2[right]: Insert any of the elements and increase that particular pointer by 1.
If one of the pointers reaches the end, then we will only move the other pointer and insert the rest of the elements of that particular array into the third array i.e. arr3[].
If we move the pointer like the above, we will get the third array in the sorted order.
Now, from sorted array arr3[], we will copy first n(size of arr1[]) elements to arr1[], and the next m(size of arr2[]) elements to arr2[].
Intuition:
Intuition is pretty straightforward. As the given arrays are sorted, we are using 2 pointer approach to get a third array, that contains all the elements from the given two arrays in the sorted order. Now, from the sorted third array, we are again filling back the given two arrays.